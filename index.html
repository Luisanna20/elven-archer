<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Elven Archer</title>
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden}
    #wrapper{width:720px;height:920px;transform-origin:top left}
    canvas{width:100%;height:100%;display:block;background:#1a1a1a;image-rendering:pixelated}
  </style>
</head>
<body>
<div id="wrapper"><canvas id="gameCanvas" width="720" height="920"></canvas></div>

<script>
/* ── масштаб ── */
function autoscale(){
  const k=Math.min(innerWidth/720,innerHeight/920);
  document.getElementById('wrapper').style.transform=`scale(${k})`;
}
addEventListener('resize',autoscale); autoscale();

/* ── canvas + helper ── */
const canvas=document.getElementById('gameCanvas'), ctx=canvas.getContext('2d');
ctx.imageSmoothingEnabled=false;
const I=s=>{const i=new Image();i.src=s;return i;};
const ready = img => img && img.complete && img.naturalWidth>0;

/* умный загрузчик одного из имён (ищет рабочий файл и запоминает его) */
function loadOneOf(candidates){
  const state={img:new Image(), ok:false};
  let i=0;
  const tryNext=()=>{
    if(i>=candidates.length){ console.warn('No sprite found for', candidates); return; }
    const src=candidates[i++] + '?v=8'; // анти-кэш
    const test=new Image();
    test.onload=()=>{ state.img=test; state.ok=true; };
    test.onerror=tryNext;
    test.src=src;
  };
  tryNext();
  return state;
}

/* ── images ── */

// Level 2 (skeleton meadow) assets
const bgBone = I('bg_bone_meadow.png');
const skelWalk = [I('skel_walk_0.png'), I('skel_walk_1.png')];
const skelShield = [I('skel_shield_0.png'), I('skel_shield_1.png')];
const skelArcher = [I('skel_archer_0.png'), I('skel_archer_1.png')];
const boneShardImg = I('bone_shard.png');


const startImg=I('StartPage.png'),  bgImg=I('background.png');
const elfR=I('elf.png'), elfL=I('elf1.png');
const elfR_taut=I('elf.png');
const elfR_release=I('elf2.png');
const elfL_taut=I('elf1.png');
const elfL_release=I('elf3.png');

const bugFr=[I('bug.png'),I('bug1.png')];
const shadowImg=I('shadow.png');
let bugFrame=0; setInterval(()=>bugFrame^=1,150);

const bossIdle=I('boss001.png'), bossHit=I('boss002.png');

const heartImg=I('heart.png');
const arrowImg=I('arrow.png'); let arrowReady=false; arrowImg.onload=()=>arrowReady=true;

// fx images
const heartBroken = loadOneOf(['heart_broken.png','hear_broken.png']);
const sparkImg = I('spark.png');


const poisonImg=I('poison.png');
const storyImg=[1,2,3,4,5,6].map(n=>I(`StoryPage00${n}.png`));

/* ── финальная сцена ── */
/* тут перебираем возможные имена файлов */
const kat = loadOneOf(['katarina.png','Katarina.png','katarina.PNG','Katarina.PNG']);
const hug = loadOneOf(['ket_miri.png','Ket_Miri.png','ket+miri.png','Ket+Miri.png','ket_miri.PNG','Ket+Miri.PNG']);
const endImg = [1,2,3].map(n=>I(`endpage00${n}.png`)); // endpage001..003

/* ── music ── */
const M=(src,vol=0)=>{const a=new Audio(src);a.loop=true;a.volume=vol;return a;};
const musMenu =M('Main_menu.mp3');
const musStory=M('Story_music.mp3');
const musGame =M('Road.mp3');
const musBoss =M('boss-fight.mp3');
const musVictory=M('Victory.mp3');

function fade(a,to,step=0.02,dt=40){
  try{ if(a._fadeId){ clearInterval(a._fadeId); a._fadeId=null; } }catch(_){}
  // clamp target
  if(to<0) to=0; else if(to>1) to=1;
  const dir = to > a.volume ? 1 : -1;
  if(dir===1 && a.paused){ try{ a.currentTime = a.currentTime||0; a.play().catch(()=>{}); }catch(_e){} }
  a._fadeId = setInterval(()=>{
    let v = a.volume + dir*step;
    if(v<0) v = 0; else if(v>1) v = 1;
    a.volume = +v.toFixed(3);
    if((dir===1 && a.volume >= to) || (dir===-1 && a.volume <= to) || a.volume===0 || a.volume===1){
      a.volume = to;
      clearInterval(a._fadeId); a._fadeId=null;
      if(to===0){ try{ a.pause(); }catch(_e){} }
    }
  }, dt);
}

/* ── on game over: stop gameplay music ── */
function onGameOver(){
  try{ fade(musGame,0); }catch(e){}
  try{ fade(musBoss,0); }catch(e){}
  try{ fade(musStory,0); }catch(e){}
  try{ fade(musVictory,0); }catch(e){}
}

/* ── sfx ── */

// hit (player) grunt + fallback mp3
const sUghWAV = new Audio('ugh_female.wav'); sUghWAV.volume = .6;
const sUghMP3 = new Audio('ugh_female.mp3'); sUghMP3.volume = .6;
function playUgh(){
  try{ sUghWAV.cloneNode().play().catch(()=>{ sUghMP3.cloneNode().play().catch(()=>{}); }); }
  catch(e){ try{ sUghMP3.cloneNode().play(); }catch(_e){} }
}
// game over sting
const sGameOver = new Audio('game-over.wav'); sGameOver.volume = .8;
function playGameOver(){ try{ sGameOver.currentTime = 0; sGameOver.play().catch(()=>{}); }catch(e){} }


const sShotB=new Audio('bow_fire.wav'); sShotB.volume=.55;
const sHitB =new Audio('bow_hit.wav');  sHitB.volume=.9;
const playShot=()=>sShotB.cloneNode().play().catch(()=>{});
const playHit =()=>sHitB.cloneNode().play().catch(()=>{});

/* ── state ── */
let phase='menu'; // menu→story→game→boss→postBoss→reunion→endSlides→credits
let audioUnlocked=false, ignoreNextClick=false;
let idx=0, fadeScr=0, fadeDir=0;
let keys={}, lives=3, score=0, gameOver=false;
let totalKills=0; // глобальный счётчик убийств (все карты подряд)
let lastShot=0, shootCD=350, bugCnt=0;
// boss spawn meter
let bossProg=0; // 0..100
const BOSS_SEC_RATE=1, BOSS_KILL_BONUS=3, BOSS_MAX=100;

/* entities */
// --- vertical scrolling state ---
let scrollBoneY=0, scrollBugY=0;
const SCROLL_BONE = 0.8;   // px per frame (skeletons)
const SCROLL_BUG  = 0.6;   // px per frame (bugs)
const BONE_LOOPS_GOAL=5, BUG_LOOPS_GOAL=5;
let boneDist=0, bugDist=0; // travel to complete level (px); keep kills trigger too

// --- transition reset helper (prevents stuck state on restart) ---
function resetTransitions(){
  try{
    transitioning = false;
    tr = { active:false, stage:0, title:'', next:'', t0:0, alpha:0, tAlpha:0 };
  }catch(_){}
}


// --- cinematic transitions (deterministic timeline) ---
let transitioning=false;
let tr={active:false, stage:0, title:'', next:'', t0:0, alpha:0, tAlpha:0};

  function startTransition(title,next){
    transitioning=true;
    tr.active=true; tr.stage=0; tr.title=title; tr.next=next; tr.t0=performance.now();
    tr.alpha=0; tr.tAlpha=0;
    try{ fade(musStory,0); }catch(_){}
    try{ fade(musGame, (next==='game'||next==='game2') ? .6 : 0); }catch(_){}
  }

// Durations (ms)
const TR_FADE_OUT=800, TR_TITLE_IN=400, TR_TITLE_HOLD=900, TR_TITLE_OUT=400, TR_FADE_IN=800;

function updateTransition(){
  if(!tr.active){ transitioning=false; return; }
  const now = performance.now();
  const dt = now - tr.t0;

  if(tr.stage===0){
    // Fade out current scene
    tr.alpha = Math.min(1, dt/ TR_FADE_OUT);
    if(dt>=TR_FADE_OUT){ tr.stage=1; tr.t0=now; tr.tAlpha=0; }
  }
  else if(tr.stage===1){
    // Title in -> hold -> out (single timeline)
    if(dt <= TR_TITLE_IN){
      tr.tAlpha = dt/ TR_TITLE_IN;
    }else if(dt <= TR_TITLE_IN + TR_TITLE_HOLD){
      tr.tAlpha = 1;
    }else if(dt <= TR_TITLE_IN + TR_TITLE_HOLD + TR_TITLE_OUT){
      const t = dt - (TR_TITLE_IN + TR_TITLE_HOLD);
      tr.tAlpha = Math.max(0, 1 - t/ TR_TITLE_OUT);
      }else{
        // Switch phase now (on black)
        if(tr.next==='game'){
          try{ skels.length=0; archers.length=0; boneShots.length=0; }catch(_){}
          score=0;
          scrollBugY=0; bugDist=0;
        }else if(tr.next==='boss'){
          bossGraceUntil = performance.now()+800;
          fade(musGame,0); fade(musBoss,.65);
          boss={x:canvas.width/2-90,y:-180,w:180,h:180,hitFlash:0,name:'Scarlet Widow'};
          bossHp=25; bossAppearing=true;
        }
        phase = tr.next;
        tr.stage=2; tr.t0=now; tr.alpha=1; tr.tAlpha=0;
      }
    }
  else if(tr.stage===2){
    // Fade into next scene
    tr.alpha = Math.max(0, 1 - dt/ TR_FADE_IN);
    if(dt>=TR_FADE_IN){ tr.alpha=0; tr.active=false; transitioning=false; }
  }

  // ultimate watchdog: if stuck >10s, finish
  if(now - (tr.startGuard|| (tr.startGuard=now)) > 10000){
    tr.active=false; transitioning=false;
  }
}

function drawTransitionOverlay(){
  if(!tr.active) return;
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,'+tr.alpha.toFixed(3)+')';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  if(tr.stage>=1){
    ctx.globalAlpha = tr.tAlpha;
    ctx.fillStyle='#fff';
    ctx.font='40px serif';
    ctx.textAlign='center';
    ctx.fillText(tr.title, canvas.width/2, canvas.height/2);
  }
  ctx.restore();
}


// Skeleton level state
let skels=[], archers=[], boneShots=[]; // arrays for level 2
let skelKills=0, SKEL_GOAL=10;

// FX state
let heartFx=null; // {x,y,until}
let sparks=[];    // [{x,y,vx,vy,life}]


const elf={x:336,y:920-48-40,w:48,h:48,img:elfR};
elf.face='R'; elf.shootFX={active:false, until:0};

const arrows=[], bugs=[], spits=[];
let boss=null, bossHp=25, bossAppearing=true;
let bossGraceUntil=0; // grace period after boss spawn (ms timestamp)

/* финальные переменные */
let end=null, reunion=null, endIdx=0, endFade=0, endFadeDir=0;

/* ── unlock first audio gesture ── */
function unlockAudio(e){
  if(audioUnlocked) return;
  e.stopImmediatePropagation(); e.preventDefault();
  ignoreNextClick=true;
  musMenu.play().then(()=>fade(musMenu,.6));
  audioUnlocked=true;
}
addEventListener('click',unlockAudio,{once:true,capture:true});
addEventListener('keydown',unlockAudio,{once:true});

/* ── controls ── */
document.addEventListener('keydown',e=>{
  keys[e.key]=true;

  // quick restart after GAME OVER
  if(gameOver && ((phase==='game2')||(phase==='game')||(phase==='boss')) && (e.key==='r'||e.key==='R'||e.key==='Enter')){
    resetGame(); return;
  }

  if(phase==='menu' && e.key==='Enter'){
    phase='story'; fade(musMenu,0); fade(musStory,.6);
  }

  // тестовый запуск босса
  if(e.key==='b' || e.key==='B') startBoss();

  const canShoot=(phase==='game2')||(phase==='game')||(phase==='boss'&&!bossAppearing);
  if(canShoot && e.key===' ' && Date.now()-lastShot>shootCD){
    arrows.push({x:elf.x+elf.w/2-8,y:elf.y,w:16,h:24,dy:-6});
    elf.shootFX.active=true; elf.shootFX.until=performance.now()+120;
    playShot(); lastShot=Date.now();
  }
});
document.addEventListener('keyup',e=>keys[e.key]=false);

canvas.addEventListener('click',()=>{
  if(ignoreNextClick){ignoreNextClick=false;return;}
  if(!audioUnlocked) return;

  if(phase==='story'){ if(!transitioning) fadeDir=1; }
  else if(phase==='menu'){ phase='story'; fade(musMenu,0); fade(musStory,.6); }
  else if(phase==='endSlides'){ if(endFadeDir===0){ endFadeDir=1; } }
  else if(phase==='credits'){ resetGame(); }
  else if(((phase==='game2')||(phase==='game')||(phase==='boss')) && gameOver){ resetGame(); } // ✅ restart on click after GAME OVER
});

/* ── helpers ── */

function spawnSparks(x,y,count=6){
  for(let i=0;i<count;i++){
    sparks.push({x:x+(Math.random()*10-5), y:y+(Math.random()*10-5),
                 vx:(Math.random()-0.5)*2, vy:-(Math.random()*1.5),
                 life:260});
  }
}


const hit=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
const lose=()=>{
  const now = performance.now();
  lives--; if(lives<0) lives=0;
  const lostIndex = lives; // zero-based
  heartFx = { x:20+lostIndex*50, y:20, until: now+240 };
  if(lives<=0){ gameOver=true; onGameOver(); playGameOver(); }
  else { playUgh(); }
};

function drawShadow(x,y,w,h,kx=0.70,ky=0.22,yOffset=6,alpha=0.65,angle=0){
  if(!(shadowImg.complete && shadowImg.naturalWidth)) return;
  const sw=Math.max(12,Math.floor(w*kx));
  const sh=Math.max(4, Math.floor(h*ky));
  const cx=Math.floor(x+w/2), cy=Math.floor(y+h-yOffset);
  ctx.save(); ctx.globalAlpha=alpha; ctx.translate(cx,cy); ctx.rotate(angle);
  ctx.drawImage(shadowImg,-sw/2,-sh/2,sw,sh); ctx.restore();
}
// --- stronger elf shadow + optional glow (skeletons only) ---
function drawElfShadow(){
  // Skeleton level: closer to feet, slightly larger + heavier alpha
  if(phase==='game2'){
    drawShadow(elf.x, elf.y, elf.w, elf.h, 0.95, 0.22, 4, 0.78, 0);
  }else{
    // Bug meadow: move down and roughly double size vs default
    drawShadow(elf.x, elf.y, elf.w, elf.h, 1.25, 0.26, 4, 0.72, 0);
  }
}
function drawElfGlow(){
  if(phase!=='game2') return; // glow only on skeleton level
  const cx = Math.floor(elf.x + elf.w/2), cy = Math.floor(elf.y + elf.h*0.55);
  const rOuter = Math.max(elf.w, elf.h)*0.75;
  const rInner = Math.max(elf.w, elf.h)*0.25;
  const g = ctx.createRadialGradient(cx, cy, rInner, cx, cy, rOuter);
  g.addColorStop(0, 'rgba(170,210,255,0.35)');
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

// draw background with vertical scrolling (seamless wrap using two draws)
function drawScrollingBG(img, offsetY){
  const h = canvas.height;
  // wrap offset to [0,h) и двигаем фон ВНИЗ по мере роста offsetY
  const y = ((offsetY % h) + h) % h;
  // рисуем два тайла: верхний и нижний, чтобы был бесшовный цикл
  ctx.drawImage(img, 0, y - h, canvas.width, h);
  ctx.drawImage(img, 0, y,      canvas.width, h);
}


/* ── update ── */
function update(){
  const now = performance.now();
  // --- Level 2: Skeletons ---
  if(phase==='game2' && !gameOver && !transitioning){
    // vertical scroll advance (skeleton level) — 5 циклов
    const _boneTarget = canvas.height * BONE_LOOPS_GOAL;
    const _boneStep = Math.min(SCROLL_BONE, Math.max(0, _boneTarget - boneDist));
    scrollBoneY += _boneStep;
    boneDist    += _boneStep;
    if(boneDist >= _boneTarget && !transitioning){
      startTransition('Bug Hive','game');
    }

    const controls=true;
    // player movement (same as game)
    if(keys.ArrowLeft  && elf.x>130){ elf.x -= 5; elf.img=elfL; elf.face='L'; }
    if(keys.ArrowRight && elf.x+elf.w<canvas.width-130){ elf.x += 5; elf.img=elfR; elf.face='R'; }

    // arrows
    arrows.forEach((a,i)=>{ a.y+=a.dy; if(a.y<-30) arrows.splice(i,1); });

    // skels move
    for(let i=skels.length-1;i>=0;i--){
      const s=skels[i];
      s.y += s.dy;
      s.x += Math.sin(now*0.003 + s.seed)*0.4;

      // shield toggle
      if(s.kind==='shield'){
        s.shieldT += 16;
        const cycle = 1200; // ms
        s.shieldUp = (s.shieldT % cycle) < 600; // half of time up
      }

      // leave screen -> life lost
      if(s.y>canvas.height){ skels.splice(i,1); continue; }

      // collide with elf
      if(hit(s,elf)){ skels.splice(i,1); lose(); continue; }
    }

    // archers patrol
    for(let i=archers.length-1;i>=0;i--){
      const a=archers[i];
      a.x += a.vx; a.y += a.vy;
      if(a.x<a.minX){a.x=a.minX; a.vx=Math.abs(a.vx);}
      if(a.x>a.maxX){a.x=a.maxX; a.vx=-Math.abs(a.vx);}
      if(a.y<a.minY){a.y=a.minY; a.vy=Math.abs(a.vy);}
      if(a.y>a.maxY){a.y=a.maxY; a.vy=-Math.abs(a.vy);}

      // shoot toward elf
      if(now - a.lastShot > a.shootCD){
        a.lastShot = now; a.shootCD = 2200 + Math.random()*1200;
        // vector to elf center
        const ex = elf.x+elf.w/2, ey = elf.y+elf.h/2;
        let dx = ex - (a.x + a.w/2), dy = ey - (a.y + a.h/2);
        const len = Math.max(1, Math.hypot(dx,dy));
        const spd = 3; dx = dx/len*spd; dy = dy/len*spd;
        boneShots.push({x:a.x+a.w/2-7, y:a.y+a.h/2-7, w:14, h:14, dx, dy});
      }

      // dead?
      if(a.hp<=0){ archers.splice(i,1); skelKills++; spawnSparks(a.x+a.w/2,a.y+a.h/2,8); totalKills++; }
    }

    // bone shots
    for(let i=boneShots.length-1;i>=0;i--){
      const p = boneShots[i];
      p.x += p.dx; p.y += p.dy;
      if(p.x<-20 || p.x>canvas.width+20 || p.y>canvas.height+20 || p.y<-20){ boneShots.splice(i,1); continue; }
      if(hit(p,elf)){ boneShots.splice(i,1); lose(); }
    }

    // arrows vs skels
    for(let ai=arrows.length-1; ai>=0; ai--){
      for(let si=skels.length-1; si>=0; si--){
        const s=skels[si], a=arrows[ai];
        if(hit(a,s)){
          // shield block?
          if(s.kind==='shield' && s.shieldUp){
            // block this arrow (no hp loss)
            arrows.splice(ai,1); spawnSparks(a.x,a.y,4);
          }else{
            s.hp--; arrows.splice(ai,1); spawnSparks(s.x+s.w/2,s.y+s.h/2,7);
            if(s.hp<=0){ skels.splice(si,1); skelKills++; totalKills++; }
          }
          break;
        }
      }
    }

    // arrows vs archers
    for(let ai=arrows.length-1; ai>=0; ai--){
      for(let ii=archers.length-1; ii>=0; ii--){
        const r=archers[ii], a=arrows[ai];
        if(hit(a,r)){
          r.hp--; arrows.splice(ai,1); spawnSparks(r.x+r.w/2,r.y+r.h/2,7);
          if(r.hp<=0){ archers.splice(ii,1); skelKills++; totalKills++; }
          break;
        }
      }
    }

    
    // update sparks (so flashes don't linger)
    for(let i=sparks.length-1;i>=0;i--){
      const p=sparks[i];
      p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; p.life-=16;
      if(p.life<=0) sparks.splice(i,1);
    }
  // level completion
  if(skelKills>=SKEL_GOAL && !transitioning){ startTransition('Bug Hive','game'); }
  }

  if((phase!=='game'&&phase!=='boss')||gameOver||transitioning) return;

// --- Bug level: вертикальный скролл «вверх» по циклам; стоп на боссе
if(phase==='game'){
  const _bugTarget = canvas.height * BUG_LOOPS_GOAL;
  const _bugStep = Math.min(SCROLL_BUG, Math.max(0, _bugTarget - bugDist));
  scrollBugY += _bugStep; bugDist += _bugStep;
  if(bugDist >= _bugTarget && !boss) startBoss();
}


  const controls=(phase==='game')||(phase==='boss');
  if(controls){
    if(keys.ArrowLeft && elf.x>130){ elf.x-=5; elf.img=elfL; elf.face='L'; }
    if(keys.ArrowRight&& elf.x+elf.w<canvas.width-130){ elf.x+=5; elf.img=elfR; elf.face='R'; }
  }

  arrows.forEach((a,i)=>{a.y+=a.dy;if(a.y<-30)arrows.splice(i,1);});

  bugs.forEach((b,i)=>{
    b.y+=b.dy;
    if(b.y>canvas.height) bugs.splice(i,1);
    if(hit(b,elf)&&controls && now>bossGraceUntil){bugs.splice(i,1);lose();}
  });

  spits.forEach((s,i)=>{
    s.y+=s.dy;
    if(s.y>canvas.height) spits.splice(i,1);
    if(hit(s,elf)&&controls && now>bossGraceUntil){spits.splice(i,1);lose();}
  });

  // update sparks (bug level)
  for(let i=sparks.length-1;i>=0;i--){
    const p=sparks[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.05; p.life-=16;
    if(p.life<=0) sparks.splice(i,1);
  }

  // arrows vs bugs
  arrows.forEach((a,ai)=>bugs.forEach((b,bi)=>{
    if(hit(a,b)){
      playHit(); spawnSparks(b.x+b.w/2,b.y+b.h/2,7); arrows.splice(ai,1); bugs.splice(bi,1); score++; totalKills++;
      bossProg = Math.min(BOSS_MAX, bossProg + BOSS_KILL_BONUS);
      if(phase==='game' && bossProg>=BOSS_MAX) startBoss();
    }
  }));

  // boss logic
  if(phase==='boss' && boss){
    if(bossAppearing){
      boss.y+=2;
      if(boss.y>100){ bossAppearing=false; boss.dir='left'; }
    }else{
      const MIN_X=210, MAX_X=510, SPEED=2;
      boss.x += boss.dir==='left'? -SPEED: SPEED;
      if(boss.x<MIN_X){boss.x=MIN_X;boss.dir='right';}
      if(boss.x>MAX_X){boss.x=MAX_X;boss.dir='left';}

      if(Math.random()<0.01){
        const n=Math.random()<0.5?1:2;
        for(let k=0;k<n;k++){
          const dx=k?12:-12;
          spits.push({x:boss.x+boss.w/2+dx,y:boss.y+boss.h,w:24,h:24,dy:3+Math.random()*2});
        }
      }
    }

    // arrows vs boss
    arrows.forEach((a,ai)=>{
      if(hit(a,boss)){
        playHit(); spawnSparks(boss.x+boss.w/2, boss.y+boss.h/2, 10); arrows.splice(ai,1);
        boss.hitFlash=20; bossHp--;
        if(bossHp<=0){ totalKills++; startFinalSequence(); }
      }
    });
  }

  // страховка: как только порог достигнут — запускаем босса
  /* loop-gate: disabled */ if(false && phase==='game' && score>=30 && !boss) startBoss();
}

/* ── spawn bugs ── */


/* ── spawn skeletons (game2) ── */
let skelFrame=0; setInterval(()=>skelFrame^=1,180);

setInterval(()=>{
  if(phase!=='game2' || gameOver || transitioning) return;

  // limit totals so поле не захламляется
  const walkers = skels.filter(s=>s.kind==='walker').length;
  const shields = skels.filter(s=>s.kind==='shield').length;
  const archCnt = archers.length;

  // spawn walkers / shields with small randomness
  if(walkers+shields < 5){
    const kind = Math.random()<0.6 ? 'walker' : 'shield';
    const x = Math.floor(80 + Math.random()*(canvas.width-160));
    const dy = kind==='walker' ? (1.20+Math.random()*0.50) : (1.00+Math.random()*0.40);
    skels.push({
      kind, x, y:-64, w:48, h:64, dy, hp:(kind==='shield'?3:2),
      anim:0, seed: Math.random()*Math.PI*2,
      shieldUp:false, shieldT:0
    });
  }

  // spawn archers up to 2
  if(archCnt < 1){
    // only spawn if fewer than 2 total archers exist
    const ax = Math.floor(100 + Math.random()*(canvas.width-200));
    const ay = Math.floor(40 + Math.random()*100);
    archers.push({
      x:ax, y:ay, w:48, h:64, hp:2,
      vx: (Math.random()<0.5?1:-1)*0.35, vy: (Math.random()<0.5?1:-1)*0.25,
      minX:40, maxX:canvas.width-88, minY:20, maxY:200,
      lastShot:0, shootCD: 2200 + Math.random()*1200,
      frame:0
    });
  }
}, 2000);


setInterval(()=>{
  if(phase!=='game'||gameOver||transitioning) return;
  bugCnt++; const speed=1.5+Math.random()*2.5;

  
  // boss meter fills over time too
  bossProg = Math.min(BOSS_MAX, bossProg + BOSS_SEC_RATE);
  /* loop-gate: disabled */ if(false && bossProg>=BOSS_MAX){ startBoss(); }
const LANE_LEFT=130, LANE_RIGHT=canvas.width-130;
  const BW=45, BH=45;
  const b={x:Math.floor(LANE_LEFT+Math.random()*(LANE_RIGHT-LANE_LEFT-BW)),
           y:0,w:BW,h:BH,dy:speed};
  bugs.push(b);
  if(bugCnt%7===0) spits.push({x:b.x+16,y:b.y+b.h,w:24,h:24,dy:speed+2});
},1000);

/* ── boss start ── */
function startBoss(){
  if(phase==='boss' || transitioning) return; // идемпотентность
  startTransition('Scarlet Widow','boss');
}

/* ── финал: от смерти босса к кат-сцене ── */
function startFinalSequence(){
  phase='postBoss'; fade(musBoss,0); fade(musVictory,.75);
  end={mode:'blink', t:performance.now(), blinkEvery:150, blinks:0, maxBlinks:6, bossAlpha:1, bossFadeMs:1000};
}

/* ── draw ── */
const drawStart=()=>ctx.drawImage(startImg,0,0,canvas.width,canvas.height);
function drawContinueHint() {
  const MARGIN = 15;              // отступ от краёв
  const RECT_W = 300, RECT_H = 40;

  const x = canvas.width  - RECT_W - MARGIN;
  const y = canvas.height - RECT_H - MARGIN;

  ctx.fillStyle = 'rgba(0,0,0,.45)';
  ctx.fillRect(x, y, RECT_W, RECT_H);

  ctx.fillStyle = '#fff';
  ctx.font = '22px monospace';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'bottom';    // базовая линия текста — нижний край
  ctx.fillText('Click to continue', canvas.width - MARGIN, canvas.height - MARGIN);
}


function drawStory(){
  const cur = (idx>=0 && idx<storyImg.length) ? storyImg[idx] : null;
  if(cur && cur.complete && cur.naturalWidth>0){
    ctx.drawImage(cur,0,0,canvas.width,canvas.height);
  }
  if(!transitioning) drawContinueHint();

  if(fadeDir){
    fadeScr+=fadeDir*0.05;
    ctx.fillStyle=`rgba(0,0,0,${fadeScr})`; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(fadeScr>=1){fadeDir=-1;fadeScr=1;idx++;
      if(idx>=storyImg.length && !transitioning){ startTransition('Bone Gorge','game2'); }
    }else if(fadeScr<=0){fadeDir=0;fadeScr=0;}
  }
}

function drawGame2(){
  // background
  drawScrollingBG(bgBone, scrollBoneY);

  // elf
    drawElfShadow(); drawElfGlow();
const _now = performance.now();
const _shot = elf.shootFX.active && _now < elf.shootFX.until;
if(elf.face==='R'){
  const img = _shot ? elfR_release : elfR_taut;
  if(ready(img)) ctx.drawImage(img, elf.x, elf.y, elf.w, elf.h);
}else{
  if(_shot){
    const img = elfR_release;
    if(ready(img)){ ctx.save(); ctx.translate(elf.x+elf.w,0); ctx.scale(-1,1); ctx.drawImage(img, 0, elf.y, elf.w, elf.h); ctx.restore(); }
  }else{
    const img = elfL_taut;
    if(ready(img)) ctx.drawImage(img, elf.x, elf.y, elf.w, elf.h);
  }
}
if(elf.shootFX.active && _now >= elf.shootFX.until) elf.shootFX.active=false;
  // arrows with glow
  arrows.forEach(a=>{
    if(arrowReady){
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.shadowColor='rgba(255,200,0,0.85)';
      ctx.shadowBlur=18;
      ctx.drawImage(arrowImg,a.x,a.y,a.w,a.h);
      ctx.restore();
      ctx.drawImage(arrowImg,a.x,a.y,a.w,a.h);
    }else{
      ctx.fillStyle='yellow'; ctx.fillRect(a.x,a.y,a.w,a.h);
    }
  });

  // skels
  skels.forEach(s=>{
    drawShadow(s.x, s.y, s.w, s.h, 0.85, 0.22, 9);
    const fr = (s.kind==='walker'? skelWalk[skelFrame] : skelShield[ s.shieldUp ? 1 : skelFrame ]);
    if(ready(fr)) ctx.drawImage(fr, s.x, s.y, s.w, s.h);
  });

  // archers
  archers.forEach(r=>{
    drawShadow(r.x, r.y, r.w, r.h, 0.85, 0.22, 9);
    const fr = skelArcher[skelFrame];
    if(ready(fr)) ctx.drawImage(fr, r.x, r.y, r.w, r.h);
  });

  // bone shards (glow + core)
  boneShots.forEach(p=>{
    if(ready(boneShardImg)){
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.shadowColor='rgba(255,255,220,0.85)'; ctx.shadowBlur=8;
      ctx.drawImage(boneShardImg, p.x, p.y, 14, 14);
      ctx.restore();
      ctx.drawImage(boneShardImg, p.x, p.y, 14, 14);
    }else{ ctx.fillStyle='#ddd'; ctx.fillRect(p.x,p.y,14,14); }
  });

  // HUD (hearts + kills)
  for(let i=0;i<lives;i++) ctx.drawImage(heartImg,20+i*50,20,40,40);
  ctx.fillStyle='#fff'; ctx.font='24px monospace'; ctx.textAlign='right';
  ctx.fillText('Total: '+totalKills,canvas.width-20,46);

  
    // Boss meter bar (top-left, above hearts)
  const BW = 210, BH = 10, BX = 20, BY = 12;// heart broken FX
  if(heartFx){
    const now = performance.now();
    if(now < heartFx.until){
      ctx.save();
      ctx.globalAlpha = 0.7 + 0.3*Math.sin(now*0.05);
      if(heartBroken.ok && ready(heartBroken.img)){
        ctx.drawImage(heartBroken.img, heartFx.x, heartFx.y, 40, 40);
      }
      ctx.restore();
    } else { heartFx=null; }
  }

  // sparks
  if(sparkImg && sparkImg.complete){
    ctx.save();
    for(const p of sparks){
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life/260));
      ctx.drawImage(sparkImg, p.x, p.y, 16, 16);
    }
    ctx.restore();
  }

if(gameOver){
    ctx.fillStyle='red'; ctx.font='48px sans-serif'; ctx.textAlign='center';
    ctx.fillText('GAME OVER',canvas.width/2,canvas.height/2);
    ctx.font='22px monospace'; ctx.fillStyle='#fff';
    ctx.fillText('Click or press R to restart',canvas.width/2,canvas.height/2+40);
  }
}

/* ── postBoss: мигание и растворение босса ── */
function drawGame(){


// --- Level 2: Skeleton Meadow ---



  drawScrollingBG(bgImg, scrollBugY);

  // эльфийка
    drawElfShadow();
const _nowg = performance.now();
const _shotg = elf.shootFX.active && _nowg < elf.shootFX.until;
if(elf.face==='R'){
  const img = _shotg ? elfR_release : elfR_taut;
  if(ready(img)) ctx.drawImage(img, elf.x, elf.y, elf.w, elf.h);
}else{
  if(_shotg){
    const img = elfR_release;
    if(ready(img)){ ctx.save(); ctx.translate(elf.x+elf.w,0); ctx.scale(-1,1); ctx.drawImage(img, 0, elf.y, elf.w, elf.h); ctx.restore(); }
  }else{
    const img = elfL_taut;
    if(ready(img)) ctx.drawImage(img, elf.x, elf.y, elf.w, elf.h);
  }
}
if(elf.shootFX.active && _nowg >= elf.shootFX.until) elf.shootFX.active=false;
  // стрелы (glow + core)
  arrows.forEach(a=>{
    if(arrowReady){
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.shadowColor='rgba(255,200,0,0.85)'; ctx.shadowBlur=18;
      ctx.drawImage(arrowImg,a.x,a.y,a.w,a.h);
      ctx.restore();
      ctx.drawImage(arrowImg,a.x,a.y,a.w,a.h);
    }else{
      ctx.fillStyle='yellow'; ctx.fillRect(a.x,a.y,a.w,a.h);
    }
  });

  // жуки
  bugs.forEach(b=>{
    drawShadow(b.x+5, b.y, b.w, b.h, 0.85, 2.00, 13, 0.60, Math.PI/2);
    ctx.drawImage(bugFr[bugFrame],b.x,b.y,b.w,b.h);
  });

  // плевки
  spits.forEach(s=>ctx.drawImage(poisonImg,s.x,s.y,s.w,s.h));

  // босс (в этой фазе)
  if(boss && phase!=='postBoss'){
    const img=(boss.hitFlash>0 && boss.hitFlash%4<2)?bossHit:bossIdle;
    drawShadow(boss.x, boss.y, boss.w, boss.h, 0.90, 0.22, 10);
    ctx.drawImage(img,boss.x,boss.y,boss.w,boss.h);
    if(boss.hitFlash>0) boss.hitFlash--;

    // hp bar + name
    const barW=180,barH=10,p=bossHp/25;
    ctx.fillStyle='#333'; ctx.fillRect(boss.x,boss.y-16,barW,barH);
    ctx.fillStyle='#e22'; ctx.fillRect(boss.x,boss.y-16,barW*p,barH);
    ctx.strokeStyle='#fff'; ctx.strokeRect(boss.x,boss.y-16,barW,barH);
    ctx.fillStyle='#fff'; ctx.font='18px monospace'; ctx.textAlign='center';
    ctx.fillText(boss.name,boss.x+boss.w/2,boss.y-26);
  }

  // HUD
  for(let i=0;i<lives;i++) ctx.drawImage(heartImg,20+i*50,20,40,40);
  ctx.fillStyle='#fff'; ctx.font='24px monospace'; ctx.textAlign='right';
  ctx.fillText('Total: '+totalKills,canvas.width-20,46);

  
    // Boss meter bar (top-left, above hearts)
  const BW = 210, BH = 10, BX = 20, BY = 12;// heart broken FX
  if(heartFx){
    const now = performance.now();
    if(now < heartFx.until){
      ctx.save();
      ctx.globalAlpha = 0.7 + 0.3*Math.sin(now*0.05);
      if(heartBroken.ok && ready(heartBroken.img)){
        ctx.drawImage(heartBroken.img, heartFx.x, heartFx.y, 40, 40);
      }
      ctx.restore();
    } else { heartFx=null; }
  }

  // sparks
  if(sparkImg && sparkImg.complete){
    ctx.save();
    for(const p of sparks){
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life/260));
      ctx.drawImage(sparkImg, p.x, p.y, 16, 16);
    }
    ctx.restore();
  }

if(gameOver){
    ctx.fillStyle='red'; ctx.font='48px sans-serif'; ctx.textAlign='center';
    ctx.fillText('GAME OVER',canvas.width/2,canvas.height/2);
    ctx.font='22px monospace'; ctx.fillStyle='#fff';
    ctx.fillText('Click or press R to restart',canvas.width/2,canvas.height/2+40);
  }
}

/* ── postBoss: мигание и растворение босса ── */
function drawPostBoss(){
  ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);

  // замороженные враги
  bugs.forEach(b=>{ drawShadow(b.x,b.y,b.w,b.h,0.70,0.20,4); ctx.drawImage(bugFr[bugFrame],b.x,b.y,b.w,b.h); });
  spits.forEach(s=>ctx.drawImage(poisonImg,s.x,s.y,s.w,s.h));

  // эльфийка
  const ang=(elf.img===elfL?-0.12:0.12);
  drawShadow(elf.x,elf.y,elf.w,elf.h,0.78,1.52,2,0.72,ang);
  ctx.drawImage(elf.img,elf.x,elf.y,elf.w,elf.h);

  // HUD
  for(let i=0;i<lives;i++) ctx.drawImage(heartImg,20+i*50,20,40,40);
  ctx.fillStyle='#fff'; ctx.font='24px monospace'; ctx.textAlign='right';
  ctx.fillText('Total: '+totalKills,canvas.width-20,46);

  
    // Boss meter bar (top-left, above hearts)
  const BW = 210, BH = 10, BX = 20, BY = 12;// страховки: если что — сразу к встрече
  if(!end || !boss){ end=null; if(!reunion) startReunion(); return; }

  const now=performance.now();
  if(end.mode==='blink'){
    if(now-end.t>=end.blinkEvery){
      end.t=now; boss._blinkOn=!boss._blinkOn; end.blinks++;
      if(end.blinks>=end.maxBlinks){ end.mode='fadeBoss'; end.t=now; }
    }
  }else if(end.mode==='fadeBoss'){
    const k=Math.min(1,(now-end.t)/end.bossFadeMs);
    end.bossAlpha=1-k;
    if(end.bossAlpha<=0){ end=null; startReunion(); return; }
  }

  const img=(end.mode==='blink' && boss._blinkOn)?bossHit:bossIdle;
  ctx.save(); ctx.globalAlpha=end.bossAlpha??1;
  drawShadow(boss.x,boss.y,boss.w,boss.h,0.90,0.22,10);
  ctx.drawImage(img,boss.x,boss.y,boss.w,boss.h); ctx.restore();
}

/* ── reunion: встреча и объятия ── */
function startReunion(){
  phase='reunion';
  arrows.length=0; bugs.length=0; spits.length=0; sparks.length=0; heartFx=null; skels.length=0; archers.length=0; boneShots.length=0; skelKills=0;
  const meetY=Math.floor(canvas.height*0.58);
  reunion={mode:'runToMeet', speed:3.2, meetY, kat:{x:Math.floor(elf.x+elf.w/2-24), y:-64, w:48, h:48}, hugT:0};
}

function drawReunion(){
  ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);

  if(reunion.mode==='runToMeet'){
    if(elf.y>reunion.meetY) elf.y-=reunion.speed;
    if(reunion.kat.y<reunion.meetY-48) reunion.kat.y+=reunion.speed;

    drawShadow(reunion.kat.x,reunion.kat.y,reunion.kat.w,reunion.kat.h,0.70,0.20,5);
    if(kat.ok && ready(kat.img)) ctx.drawImage(kat.img,reunion.kat.x,reunion.kat.y,reunion.kat.w,reunion.kat.h);

    drawShadow(elf.x,elf.y,elf.w,elf.h);
    if(ready(elf.img)) ctx.drawImage(elf.img,elf.x,elf.y,elf.w,elf.h);

    if(elf.y<=reunion.meetY && reunion.kat.y>=reunion.meetY-48){ reunion.mode='hug'; reunion.hugT=performance.now(); }

  }else if(reunion.mode==='hug'){
    const hx=Math.floor(elf.x+elf.w/2-64), hy=Math.floor(reunion.meetY-72);
    const showHug = hug.ok && ready(hug.img);

    if(showHug){ drawShadow(hx,hy,128,128,0.85,0.18,8); ctx.drawImage(hug.img,hx,hy,128,128); }
    else{
      drawShadow(reunion.kat.x,reunion.kat.y,reunion.kat.w,reunion.kat.h,0.70,0.20,5);
      if(kat.ok && ready(kat.img)) ctx.drawImage(kat.img,reunion.kat.x,reunion.kat.y,reunion.kat.w,reunion.kat.h);
      drawShadow(elf.x,elf.y,elf.w,elf.h);
      if(ready(elf.img)) ctx.drawImage(elf.img,elf.x,elf.y,elf.w,elf.h);
    }

    // ждём минимум 1.2s, но не дольше 3s
    const elapsed = performance.now() - reunion.hugT;
    const HUG_MIN = 1200, HUG_MAX_WAIT = 3000;
    if ((showHug && elapsed > HUG_MIN) || elapsed > HUG_MAX_WAIT){
      reunion.mode='fadeToBlack'; endFade=0; endFadeDir=1;
    }

  }else if(reunion.mode==='fadeToBlack'){
    const hx=Math.floor(elf.x+elf.w/2-64), hy=Math.floor(reunion.meetY-72);
    if(hug.ok && ready(hug.img)){ drawShadow(hx,hy,128,128,0.85,0.18,8); ctx.drawImage(hug.img,hx,hy,128,128); }
    else{
      drawShadow(reunion.kat.x,reunion.kat.y,reunion.kat.w,reunion.kat.h,0.70,0.20,5);
      if(kat.ok && ready(kat.img)) ctx.drawImage(kat.img,reunion.kat.x,reunion.kat.y,reunion.kat.w,reunion.kat.h);
      drawShadow(elf.x,elf.y,elf.w,elf.h);
      if(ready(elf.img)) ctx.drawImage(elf.img,elf.x,elf.y,elf.w,elf.h);
    }
    endFade=Math.min(1,endFade+0.04);
    ctx.fillStyle=`rgba(0,0,0,${endFade})`; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(endFade>=1){ phase='endSlides'; endIdx=0; endFade=1; endFadeDir=-1; }
  }
}

/* ── финальные слайды ── */
function drawEndSlides(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const img=endImg[endIdx];
  if(ready(img)){
    const scale=Math.min(canvas.width/img.width, canvas.height/img.height);
    const dw=Math.floor(img.width*scale), dh=Math.floor(img.height*scale);
    const dx=Math.floor((canvas.width-dw)/2), dy=Math.floor((canvas.height-dh)/2);
    ctx.drawImage(img,dx,dy,dw,dh);
  }
drawContinueHint();

  if(endFadeDir!==0){
    endFade+=endFadeDir*0.05; endFade=Math.max(0,Math.min(1,endFade));
    ctx.fillStyle=`rgba(0,0,0,${endFade})`; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(endFade>=1 && endFadeDir>0){
      endIdx++; if(endIdx>=endImg.length){ phase='credits'; } else { endFadeDir=-1; }
    }else if(endFade<=0 && endFadeDir<0){ endFadeDir=0; }
  }
}

/* ── титры ── */
function drawCredits(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const t=(performance.now()/1000)%2, pulse=0.85+0.15*Math.sin(t*Math.PI);
  ctx.fillStyle='#fff'; ctx.textAlign='center';
  ctx.font=`${Math.floor(42*pulse)}px monospace`; ctx.fillText('THE END', canvas.width/2, 150);
  ctx.font='24px monospace';
  ctx.fillText('Idea & Inspiration: Katarina', canvas.width/2, 300);
  ctx.fillText('Code & Art: ChatGPT (aka Miriel)', canvas.width/2, 340);
  ctx.font='20px monospace'; ctx.fillText('© 2025', canvas.width/2, 400);
  ctx.font='22px monospace'; ctx.fillText('Click to restart', canvas.width/2, 520);
}

/* ── main loop ── */
(function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(phase==='menu') drawStart();
  else if(phase==='story') drawStory();
  else if(phase==='game2'){ update(); drawGame2(); }
  else if(phase==='game'||phase==='boss'){ update(); drawGame(); }
  else if(phase==='postBoss'){ drawPostBoss(); }
  else if(phase==='reunion'){ drawReunion(); }
  else if(phase==='endSlides'){ drawEndSlides(); }
  else if(phase==='credits'){ drawCredits(); }
  updateTransition();
  drawTransitionOverlay();
  requestAnimationFrame(loop);
})();

/* ── reset ── */
function resetGame(){
  scrollBoneY=0; scrollBugY=0; boneDist=0; 
  resetTransitions();
  gameOver=false; bossGraceUntil=0;

  fade(musGame,0); fade(musBoss,0); fade(musStory,0); fade(musVictory,0); fade(musMenu,.6);
  phase='menu'; audioUnlocked=true; ignoreNextClick=false;
  idx=0; fadeScr=0; fadeDir=0; keys={}; lives=3; score=0; gameOver=false; lastShot=0; bugCnt=0; bossProg=0;
  elf.x=336; elf.y=920-48-40; elf.img=elfR;
  arrows.length=0; bugs.length=0; spits.length=0; sparks.length=0; heartFx=null; skels.length=0; archers.length=0; boneShots.length=0; skelKills=0;
  boss=null; bossHp=25; bossAppearing=true;
  bugDist=0; totalKills=0;
  end=null; reunion=null; endIdx=0; endFade=0; endFadeDir=0;
}

/* ── мини-диагностика: если sprite не найден, покажем это на экране ── */
setTimeout(()=>{
  if(!hug.ok){
    const c=canvas.getContext('2d');
    c.fillStyle='rgba(0,0,0,.6)'; c.fillRect(20,20,680,60);
    c.fillStyle='#ff7070'; c.font='18px monospace';
    c.fillText('Hug sprite not found. Tried: ket_miri.png / Ket_Miri.png / ket+miri.png / Ket+Miri.png', 30, 58);
  }
}, 2000);
</script>
</body>
</html>
